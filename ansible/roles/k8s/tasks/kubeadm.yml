---

- name: Generate kubeadm.conf for No Cloud provider
  become: true
  ansible.builtin.template:
    src: templates/{{ k8s_cloud }}-cloud-kubeadm.conf.j2
    dest: /etc/kubernetes/kubeadm.conf
    mode: '0644'

- name: Init first manager node
  become: true
  when: k8s_managers_group_name in group_names
  ansible.builtin.shell: |
    kubeadm reset -f
    kubeadm init --config /etc/kubernetes/kubeadm.conf
  args:
    creates: "{{ ansible_env.HOME }}/.kube/config"
  run_once: true
  delegate_to: "{{ k8s_man01_hostname }}"

- name: Check if pki folder already exists
  ansible.builtin.stat:
    path: /etc/kubernetes/pki
  register: k8s_is_pki_folder
  changed_when: false

- name: Archive pki folder from man01
  become: true
  when:
    - inventory_hostname != k8s_man01_hostname
    - k8s_managers_group_name in group_names
    - not k8s_is_pki_folder.stat.exists
  community.general.archive:
    path: /etc/kubernetes/pki/*
    dest: "{{ ansible_env.HOME }}/pki.tar.gz"
    mode: '0640'
    format: gz
  run_once: true
  delegate_to: "{{ k8s_man01_hostname }}"

- name: Get pki folder in local
  become: true
  when:
    - inventory_hostname != k8s_man01_hostname
    - k8s_managers_group_name in group_names
    - not k8s_is_pki_folder.stat.exists
  ansible.builtin.fetch:
    src: "{{ ansible_env.HOME }}/pki.tar.gz"
    dest: assets/files/
    flat: true
  run_once: true
  delegate_to: "{{ k8s_man01_hostname }}"

- name: Ensure pki folder exists
  become: true
  when:
    - inventory_hostname != k8s_man01_hostname
    - k8s_managers_group_name in group_names
  ansible.builtin.file:
    path: /etc/kubernetes/pki
    state: directory
    mode: '0755'

- name: Synchronization of pki folder to destination
  become: true
  when:
    - inventory_hostname != k8s_man01_hostname
    - k8s_managers_group_name in group_names
    - not k8s_is_pki_folder.stat.exists
  ansible.builtin.unarchive:
    src: assets/files/pki.tar.gz
    dest: /etc/kubernetes/pki

- name: Get token from control-plane node
  become: true
  when: inventory_hostname != k8s_man01_hostname
  ansible.builtin.shell: |
    set -e -o pipefail
    kubeadm token create --print-join-command
  args:
    executable: /bin/bash
  register: k8s_token_cmd
  delegate_to: "{{ k8s_man01_hostname }}"
  changed_when: false

- name: Add other manager nodes
  become: true
  when:
    - k8s_managers_group_name in group_names
    - inventory_hostname != k8s_man01_hostname
  ansible.builtin.shell: >
    {{ k8s_token_cmd.stdout }} --node-name {{ inventory_hostname }} --cri-socket=unix:///var/run/crio/crio.sock
    --control-plane --apiserver-advertise-address {{ k8s_node_ip }} --apiserver-bind-port {{ k8s_controlplane_port }} &&
    touch {{ ansible_env.HOME }}/.k8sinstall
  args:
    creates: "{{ ansible_env.HOME }}/.k8sinstall"

- name: Add k8snode
  become: true
  when: k8s_nodes_group_name in group_names
  ansible.builtin.shell: >
    {{ k8s_token_cmd.stdout }} --node-name {{ inventory_hostname }} --cri-socket=unix:///var/run/crio/crio.sock &&
    touch {{ ansible_env.HOME }}/.k8sinstall
  args:
    creates: "{{ ansible_env.HOME }}/.k8sinstall"

- name: Wait for local kubernetes API is reachable
  when: k8s_managers_group_name in group_names
  ansible.builtin.wait_for:
    host: "{{ k8s_node_ip }}"
    port: "{{ k8s_controlplane_port }}"
    delay: 5

- name: Wait for VIP kubernetes API is reachable
  when: k8s_managers_group_name in group_names
  ansible.builtin.wait_for:
    host: "{{ k8s_controlplane_endpoint_ip }}"
    port: "{{ k8s_controlplane_port }}"
    delay: 5

- name: Ensure kubelet is in a running state
  become: true
  ansible.builtin.service:
    name: kubelet
    state: started
  register: k8s_kubelet_details
  until: k8s_kubelet_details.status.ActiveState == "active"
  retries: 25
  delay: 20

...
